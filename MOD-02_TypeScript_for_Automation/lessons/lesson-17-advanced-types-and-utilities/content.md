# Lesson 17: Advanced Types and Utility Types

## Learning Objectives
- Understand and use advanced types like `keyof` and `typeof`.
- Learn about mapped types to transform existing types.
- Explore conditional types to create types based on conditions.
- Use built-in utility types like `Partial`, `Required`, `Readonly`, `Pick`, and `Omit` to manipulate types.

## Introduction
TypeScript provides several advanced and utility types that allow you to manipulate and create new types from existing ones. Mastering these tools is essential for building highly flexible, maintainable, and robust test automation frameworks, as they help you keep your types consistent and reduce code duplication.

## The `keyof` Type Operator
The `keyof` operator takes an object type and produces a string or numeric literal union of its keys.

```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

// UserKeys will be the type "id" | "name" | "email"
type UserKeys = keyof User;

function getProperty(user: User, key: UserKeys) {
  return user[key];
}

const user: User = { id: 1, name: "Jane Doe", email: "jane@example.com" };
const username = getProperty(user, "name"); // Correct
// const error = getProperty(user, "password"); // Error: Argument of type '"password"' is not assignable to parameter of type 'keyof User'.
```
This is incredibly useful for creating type-safe functions that access object properties dynamically.

## The `typeof` Type Operator
The `typeof` operator can be used in a type context to refer to the type of a variable or property.

```typescript
const testConfig = {
  baseUrl: "https://example.com",
  timeout: 5000,
  headless: true,
};

// Create a type that matches the shape of the testConfig object
type TestConfig = typeof testConfig;

const anotherConfig: TestConfig = {
  baseUrl: "https://another-example.com",
  timeout: 10000,
  headless: false,
};
```
This is useful for creating types from existing constants or data structures without having to define them manually.

## Mapped Types
Mapped types allow you to create new types by transforming the properties of an existing type. The syntax is similar to a `for...in` loop for types.

```typescript
type Stringify<T> = {
  [K in keyof T]: string;
};

interface Point {
  x: number;
  y: number;
}

// The 'StringPoint' type will be { x: string; y: string; }
type StringPoint = Stringify<Point>;
```

## Built-in Utility Types
TypeScript comes with a set of utility types that make common type transformations easy. These are built using the advanced concepts above.

### `Partial<T>`
Constructs a type with all properties of `T` set to optional. This is great for creating "update" objects where you only want to provide a subset of properties.

```typescript
interface TestSettings {
  browser: "chrome" | "firefox" | "webkit";
  retries: number;
}

// A function to update settings
function updateSettings(updates: Partial<TestSettings>) {
  // ... implementation
}

// You can pass an object with some or all of the properties
updateSettings({ browser: "firefox" });
updateSettings({ retries: 2, browser: "webkit" });
```

### `Required<T>`
Constructs a type with all properties of `T` set to required. It's the opposite of `Partial`.

### `Readonly<T>`
Constructs a type with all properties of `T` set to `readonly`, meaning they cannot be reassigned.

```typescript
const defaultConfig: Readonly<TestSettings> = {
  browser: "chrome",
  retries: 0,
};

// defaultConfig.browser = "firefox"; // Error: Cannot assign to 'browser' because it is a read-only property.
```

### `Pick<T, K>`
Constructs a type by picking a set of properties `K` from a type `T`.

```typescript
interface ApiUser {
  id: number;
  username: string;
  email: string;
  apiKey: string;
  lastLogin: Date;
}

// Create a type with only the properties we want to display publicly
type PublicUser = Pick<ApiUser, "id" | "username">;

const publicProfile: PublicUser = {
  id: 1,
  username: "public-user",
};
```

### `Omit<T, K>`
Constructs a type by picking all properties from `T` and then removing `K`. It's the opposite of `Pick`.

```typescript
// Create a type for a new user, omitting the properties that are generated by the system
type NewUserPayload = Omit<ApiUser, "id" | "apiKey" | "lastLogin">;

const newUser: NewUserPayload = {
  username: "newbie",
  email: "newbie@example.com",
};
```

## Summary
- **`keyof`** creates a union type of an object's keys.
- **`typeof`** creates a type from a value (like a constant object).
- **Mapped types** allow you to transform the properties of an existing type into a new type.
- **Utility types** like `Partial`, `Readonly`, `Pick`, and `Omit` provide powerful, reusable ways to manipulate your types, leading to cleaner, more maintainable, and more expressive code in your test automation framework.

Using these advanced and utility types effectively will significantly improve your ability to create flexible and robust data models for your tests.