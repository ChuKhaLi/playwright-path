# Exercise 03: Advanced Execution Control Project

## üéØ Exercise Overview

**Objective**: Build sophisticated test execution control systems using complex tag expressions, intelligent filtering, environment integration, and CI/CD automation patterns for production-ready test management.

**Duration**: 45 minutes  
**Complexity**: Advanced  
**Skills Focus**: Complex tag expressions, command-line mastery, environment integration, CI/CD automation

## üìö Learning Objectives

By completing this exercise, you will be able to:

1. **LO1**: Master complex tag expressions with advanced boolean logic and conditions
2. **LO2**: Build intelligent test selection systems based on runtime conditions
3. **LO3**: Integrate environment variables and external configuration for dynamic execution
4. **LO4**: Create CI/CD-optimized execution workflows with performance considerations
5. **LO5**: Implement sophisticated failure handling and retry mechanisms

## üõ†Ô∏è Setup Requirements

### **Prerequisites**
- Completion of Exercises 01-02 (Hook Implementation and Tag Strategy)
- Understanding of CI/CD pipeline concepts
- Familiarity with environment variable management
- Basic knowledge of performance optimization techniques

### **Advanced Setup**
```bash
# Create comprehensive exercise environment
mkdir advanced-execution-control-project
cd advanced-execution-control-project

# Initialize with full toolchain
npm init -y
npm install --save-dev @cucumber/cucumber typescript ts-node
npm install --save-dev dotenv yargs chalk
npm install --save-dev @types/node @types/yargs

# Create advanced directory structure
mkdir -p {features,step-definitions,hooks,support,config,scripts,reports,logs}
mkdir -p config/{environments,filters,strategies,performance}
mkdir -p features/{critical,regression,integration,performance}
mkdir -p scripts/{ci,analysis,reporting}
```

### **Environment Configuration**
```bash
# .env.example
NODE_ENV=development
TEST_ENVIRONMENT=local
BROWSER_POOL_SIZE=3
MAX_RETRY_COUNT=2
PERFORMANCE_THRESHOLD=5000
PARALLEL_WORKERS=4
FEATURE_FLAGS=new-ui,beta-api,enhanced-search
TEAM_ASSIGNMENT=frontend,backend,qa
EXECUTION_TIMEOUT=30000
REPORTING_ENABLED=true
SLACK_WEBHOOK_URL=https://hooks.slack.com/...
```

## üìã Project Tasks

### **Task 1: Build Advanced Tag Expression Engine (15 minutes)**

Create a sophisticated tag expression parser and evaluator with advanced features.

**File**: `config/tag-expression-engine.ts`

```typescript
// config/tag-expression-engine.ts
/**
 * TODO: Build advanced tag expression engine
 * Requirements:
 * 1. Parse complex boolean expressions with nested conditions
 * 2. Support runtime variable substitution
 * 3. Implement performance-optimized evaluation
 * 4. Add conditional logic based on environment state
 * 5. Support dynamic tag generation and filtering
 */

export interface ExpressionContext {
    environment: string;
    team?: string;
    featureFlags: string[];
    performance: {
        cpu: number;
        memory: number;
        networkLatency: number;
    };
    timeConstraints: {
        maxDuration: number;
        startTime: Date;
    };
    ciContext?: {
        branch: string;
        pullRequest?: number;
        triggeredBy: string;
    };
}

export interface TagExpression {
    raw: string;
    parsed: ExpressionNode;
    variables: string[];
    complexity: number;
}

export interface ExpressionNode {
    type: 'tag' | 'and' | 'or' | 'not' | 'group' | 'condition';
    value?: string;
    children?: ExpressionNode[];
    condition?: RuntimeCondition;
}

export interface RuntimeCondition {
    type: 'environment' | 'performance' | 'time' | 'feature-flag' | 'team';
    operator: 'equals' | 'contains' | 'gt' | 'lt' | 'exists';
    value: any;
}

// TODO: Implement TagExpressionEngine class with:
// - parseExpression(expression: string): TagExpression
// - evaluateExpression(expression: TagExpression, context: ExpressionContext): boolean
// - optimizeExpression(expression: TagExpression): TagExpression
// - generateDynamicTags(context: ExpressionContext): string[]
// - validateExpression(expression: string): ValidationResult
```

**Expected Implementation:**
```typescript
// config/tag-expression-engine.ts - Solution
export interface ExpressionContext {
    environment: string;
    team?: string;
    featureFlags: string[];
    performance: {
        cpu: number;
        memory: number;
        networkLatency: number;
    };
    timeConstraints: {
        maxDuration: number;
        startTime: Date;
    };
    ciContext?: {
        branch: string;
        pullRequest?: number;
        triggeredBy: string;
    };
}

export interface TagExpression {
    raw: string;
    parsed: ExpressionNode;
    variables: string[];
    complexity: number;
}

export interface ExpressionNode {
    type: 'tag' | 'and' | 'or' | 'not' | 'group' | 'condition';
    value?: string;
    children?: ExpressionNode[];
    condition?: RuntimeCondition;
}

export interface RuntimeCondition {
    type: 'environment' | 'performance' | 'time' | 'feature-flag' | 'team';
    operator: 'equals' | 'contains' | 'gt' | 'lt' | 'exists';
    value: any;
}

export class TagExpressionEngine {
    private static readonly OPERATORS = ['and', 'or', 'not'];
    private static readonly RESERVED_WORDS = [...TagExpressionEngine.OPERATORS, 'true', 'false'];
    
    static parseExpression(expression: string): TagExpression {
        const tokens = this.tokenize(expression);
        const parsed = this.parseTokens(tokens);
        const variables = this.extractVariables(parsed);
        const complexity = this.calculateComplexity(parsed);
        
        return {
            raw: expression,
            parsed,
            variables,
            complexity
        };
    }
    
    static evaluateExpression(expression: TagExpression, context: ExpressionContext, scenarioTags: string[]): boolean {
        return this.evaluateNode(expression.parsed, context, scenarioTags);
    }
    
    static optimizeExpression(expression: TagExpression): TagExpression {
        const optimized = this.optimizeNode(expression.parsed);
        
        return {
            ...expression,
            parsed: optimized,
            complexity: this.calculateComplexity(optimized)
        };
    }
    
    static generateDynamicTags(context: ExpressionContext): string[] {
        const dynamicTags: string[] = [];
        
        // Environment-based tags
        dynamicTags.push(`@env-${context.environment}`);\n        
        // Performance-based tags
        if (context.performance.cpu < 50) {\n            dynamicTags.push('@fast-cpu');\n        } else if (context.performance.cpu > 80) {\n            dynamicTags.push('@slow-cpu');\n        }\n        \n        if (context.performance.memory < 70) {\n            dynamicTags.push('@low-memory');\n        } else {\n            dynamicTags.push('@high-memory');\n        }\n        \n        // Feature flag tags\n        context.featureFlags.forEach(flag => {\n            dynamicTags.push(`@feature-${flag.replace(/_/g, '-')}`);\n        });\n        \n        // Team-based tags\n        if (context.team) {\n            dynamicTags.push(`@team-${context.team}`);\n        }\n        \n        // Time-based tags\n        const hour = new Date().getHours();\n        if (hour >= 9 && hour <= 17) {\n            dynamicTags.push('@business-hours');\n        } else {\n            dynamicTags.push('@after-hours');\n        }\n        \n        // CI context tags\n        if (context.ciContext) {\n            dynamicTags.push(`@branch-${context.ciContext.branch.replace(/[^a-z0-9]/gi, '-')}`);\n            if (context.ciContext.pullRequest) {\n                dynamicTags.push('@pull-request');\n            }\n        }\n        \n        return dynamicTags;\n    }\n    \n    static validateExpression(expression: string): ValidationResult {\n        const errors: string[] = [];\n        const warnings: string[] = [];\n        \n        try {\n            const parsed = this.parseExpression(expression);\n            \n            // Check complexity\n            if (parsed.complexity > 10) {\n                warnings.push('Expression complexity is high, consider simplification');\n            }\n            \n            // Check for common issues\n            if (expression.includes('@@')) {\n                errors.push('Double @ symbols are not allowed');\n            }\n            \n            if (expression.includes('and and') || expression.includes('or or')) {\n                errors.push('Duplicate logical operators detected');\n            }\n            \n            // Validate parentheses matching\n            const openParens = (expression.match(/\\(/g) || []).length;\n            const closeParens = (expression.match(/\\)/g) || []).length;\n            if (openParens !== closeParens) {\n                errors.push('Mismatched parentheses');\n            }\n            \n        } catch (error) {\n            errors.push(`Parse error: ${error.message}`);\n        }\n        \n        return {\n            isValid: errors.length === 0,\n            errors,\n            warnings\n        };\n    }\n    \n    private static tokenize(expression: string): string[] {\n        // Simplified tokenization - in production, use a proper lexer\n        return expression\n            .replace(/[()]/g, ' $& ')\n            .split(/\\s+/)\n            .filter(token => token.length > 0);\n    }\n    \n    private static parseTokens(tokens: string[]): ExpressionNode {\n        // Simplified recursive descent parser\n        let index = 0;\n        \n        function parseOr(): ExpressionNode {\n            let left = parseAnd();\n            \n            while (index < tokens.length && tokens[index] === 'or') {\n                index++; // consume 'or'\n                const right = parseAnd();\n                left = {\n                    type: 'or',\n                    children: [left, right]\n                };\n            }\n            \n            return left;\n        }\n        \n        function parseAnd(): ExpressionNode {\n            let left = parseNot();\n            \n            while (index < tokens.length && tokens[index] === 'and') {\n                index++; // consume 'and'\n                const right = parseNot();\n                left = {\n                    type: 'and',\n                    children: [left, right]\n                };\n            }\n            \n            return left;\n        }\n        \n        function parseNot(): ExpressionNode {\n            if (index < tokens.length && tokens[index] === 'not') {\n                index++; // consume 'not'\n                return {\n                    type: 'not',\n                    children: [parseAtom()]\n                };\n            }\n            \n            return parseAtom();\n        }\n        \n        function parseAtom(): ExpressionNode {\n            if (index >= tokens.length) {\n                throw new Error('Unexpected end of expression');\n            }\n            \n            const token = tokens[index++];\n            \n            if (token === '(') {\n                const node = parseOr();\n                if (index >= tokens.length || tokens[index] !== ')') {\n                    throw new Error('Missing closing parenthesis');\n                }\n                index++; // consume ')'\n                return {\n                    type: 'group',\n                    children: [node]\n                };\n            }\n            \n            if (token.startsWith('@')) {\n                return {\n                    type: 'tag',\n                    value: token\n                };\n            }\n            \n            throw new Error(`Unexpected token: ${token}`);\n        }\n        \n        return parseOr();\n    }\n    \n    private static evaluateNode(node: ExpressionNode, context: ExpressionContext, scenarioTags: string[]): boolean {\n        switch (node.type) {\n            case 'tag':\n                return scenarioTags.includes(node.value!);\n                \n            case 'and':\n                return node.children!.every(child => this.evaluateNode(child, context, scenarioTags));\n                \n            case 'or':\n                return node.children!.some(child => this.evaluateNode(child, context, scenarioTags));\n                \n            case 'not':\n                return !this.evaluateNode(node.children![0], context, scenarioTags);\n                \n            case 'group':\n                return this.evaluateNode(node.children![0], context, scenarioTags);\n                \n            case 'condition':\n                return this.evaluateCondition(node.condition!, context);\n                \n            default:\n                throw new Error(`Unknown node type: ${node.type}`);\n        }\n    }\n    \n    private static evaluateCondition(condition: RuntimeCondition, context: ExpressionContext): boolean {\n        switch (condition.type) {\n            case 'environment':\n                return condition.operator === 'equals' \n                    ? context.environment === condition.value\n                    : false;\n                    \n            case 'performance':\n                const perfValue = context.performance[condition.value as keyof typeof context.performance];\n                switch (condition.operator) {\n                    case 'gt': return perfValue > condition.value;\n                    case 'lt': return perfValue < condition.value;\n                    default: return false;\n                }\n                \n            case 'feature-flag':\n                return context.featureFlags.includes(condition.value);\n                \n            case 'team':\n                return context.team === condition.value;\n                \n            default:\n                return false;\n        }\n    }\n    \n    private static optimizeNode(node: ExpressionNode): ExpressionNode {\n        // Simple optimizations - remove redundant groups, flatten nested operators\n        if (node.type === 'group' && node.children && node.children.length === 1) {\n            return this.optimizeNode(node.children[0]);\n        }\n        \n        if (node.children) {\n            node.children = node.children.map(child => this.optimizeNode(child));\n        }\n        \n        return node;\n    }\n    \n    private static extractVariables(node: ExpressionNode): string[] {\n        const variables: string[] = [];\n        \n        if (node.type === 'tag' && node.value?.includes('${')) {\n            const matches = node.value.match(/\\$\\{([^}]+)\\}/g);\n            if (matches) {\n                variables.push(...matches.map(match => match.slice(2, -1)));\n            }\n        }\n        \n        if (node.children) {\n            for (const child of node.children) {\n                variables.push(...this.extractVariables(child));\n            }\n        }\n        \n        return [...new Set(variables)];\n    }\n    \n    private static calculateComplexity(node: ExpressionNode): number {\n        let complexity = 1;\n        \n        if (node.children) {\n            for (const child of node.children) {\n                complexity += this.calculateComplexity(child);\n            }\n        }\n        \n        return complexity;\n    }\n}\n\nexport interface ValidationResult {\n    isValid: boolean;\n    errors: string[];\n    warnings: string[];\n}\n```\n\n### **Task 2: Implement Intelligent Test Selection (15 minutes)**\n\nBuild a system that intelligently selects tests based on multiple factors.\n\n**File**: `config/intelligent-selector.ts`\n\n```typescript\n// config/intelligent-selector.ts\n/**\n * TODO: Build intelligent test selection system\n * Requirements:\n * 1. Analyze code changes to determine affected test areas\n * 2. Consider historical failure patterns and flakiness\n * 3. Balance execution time with coverage requirements\n * 4. Adapt selection based on environment and context\n * 5. Implement machine learning-inspired prioritization\n */\n\nexport interface TestScenario {\n    name: string;\n    tags: string[];\n    filePath: string;\n    estimatedDuration: number;\n    historicalData: {\n        successRate: number;\n        averageDuration: number;\n        lastFailure?: Date;\n        flakiness: number; // 0-1 score\n    };\n    dependencies: string[];\n    coverage: {\n        codeAreas: string[];\n        businessFunctions: string[];\n    };\n}\n\nexport interface SelectionCriteria {\n    maxDuration?: number;\n    minCoverage?: number;\n    riskTolerance: 'low' | 'medium' | 'high';\n    prioritizeFailures: boolean;\n    includeFlaky: boolean;\n    codeChanges?: {\n        modifiedFiles: string[];\n        affectedAreas: string[];\n    };\n}\n\nexport interface SelectionResult {\n    selectedScenarios: TestScenario[];\n    totalEstimatedDuration: number;\n    coverageMetrics: {\n        codeAreasCovered: string[];\n        businessFunctionsCovered: string[];\n        coveragePercentage: number;\n    };\n    riskAssessment: {\n        highRiskScenarios: number;\n        expectedFailures: number;\n        confidenceLevel: number;\n    };\n    reasoning: string[];\n}\n\n// TODO: Implement IntelligentTestSelector class with:\n// - selectTests(scenarios: TestScenario[], criteria: SelectionCriteria): SelectionResult\n// - prioritizeByRisk(scenarios: TestScenario[]): TestScenario[]\n// - optimizeForTime(scenarios: TestScenario[], maxTime: number): TestScenario[]\n// - calculateCoverage(scenarios: TestScenario[]): CoverageMetrics\n// - predictFailures(scenarios: TestScenario[]): FailurePrediction[]\n```\n\n**Expected Implementation:**\n```typescript\n// config/intelligent-selector.ts - Solution\nexport interface TestScenario {\n    name: string;\n    tags: string[];\n    filePath: string;\n    estimatedDuration: number;\n    historicalData: {\n        successRate: number;\n        averageDuration: number;\n        lastFailure?: Date;\n        flakiness: number;\n    };\n    dependencies: string[];\n    coverage: {\n        codeAreas: string[];\n        businessFunctions: string[];\n    };\n}\n\nexport interface SelectionCriteria {\n    maxDuration?: number;\n    minCoverage?: number;\n    riskTolerance: 'low' | 'medium' | 'high';\n    prioritizeFailures: boolean;\n    includeFlaky: boolean;\n    codeChanges?: {\n        modifiedFiles: string[];\n        affectedAreas: string[];\n    };\n}\n\nexport interface SelectionResult {\n    selectedScenarios: TestScenario[];\n    totalEstimatedDuration: number;\n    coverageMetrics: {\n        codeAreasCovered: string[];\n        businessFunctionsCovered: string[];\n        coveragePercentage: number;\n    };\n    riskAssessment: {\n        highRiskScenarios: number;\n        expectedFailures: number;\n        confidenceLevel: number;\n    };\n    reasoning: string[];\n}\n\nexport class IntelligentTestSelector {\n    static selectTests(scenarios: TestScenario[], criteria: SelectionCriteria): SelectionResult {\n        let candidateScenarios = [...scenarios];\n        const reasoning: string[] = [];\n        \n        // Phase 1: Filter by basic criteria\n        if (!criteria.includeFlaky) {\n            const beforeCount = candidateScenarios.length;\n            candidateScenarios = candidateScenarios.filter(s => s.historicalData.flakiness < 0.3);\n            reasoning.push(`Filtered out ${beforeCount - candidateScenarios.length} flaky scenarios`);\n        }\n        \n        // Phase 2: Prioritize based on code changes\n        if (criteria.codeChanges) {\n            candidateScenarios = this.prioritizeByCodeChanges(candidateScenarios, criteria.codeChanges);\n            reasoning.push('Prioritized scenarios based on code changes');\n        }\n        \n        // Phase 3: Risk-based prioritization\n        candidateScenarios = this.prioritizeByRisk(candidateScenarios, criteria.riskTolerance);\n        reasoning.push(`Applied ${criteria.riskTolerance} risk tolerance prioritization`);\n        \n        // Phase 4: Time optimization\n        if (criteria.maxDuration) {\n            candidateScenarios = this.optimizeForTime(candidateScenarios, criteria.maxDuration);\n            reasoning.push(`Optimized selection for ${criteria.maxDuration}ms time constraint`);\n        }\n        \n        // Phase 5: Coverage optimization\n        if (criteria.minCoverage) {\n            candidateScenarios = this.optimizeForCoverage(candidateScenarios, criteria.minCoverage);\n            reasoning.push(`Ensured minimum ${criteria.minCoverage}% coverage`);\n        }\n        \n        // Calculate final metrics\n        const coverageMetrics = this.calculateCoverage(candidateScenarios, scenarios);\n        const riskAssessment = this.assessRisk(candidateScenarios);\n        const totalDuration = candidateScenarios.reduce((sum, s) => sum + s.estimatedDuration, 0);\n        \n        return {\n            selectedScenarios: candidateScenarios,\n            totalEstimatedDuration: totalDuration,\n            coverageMetrics,\n            riskAssessment,\n            reasoning\n        };\n    }\n    \n    static prioritizeByRisk(scenarios: TestScenario[], riskTolerance: string = 'medium'): TestScenario[] {\n        return scenarios.sort((a, b) => {\n            const riskScoreA = this.calculateRiskScore(a, riskTolerance);\n            const riskScoreB = this.calculateRiskScore(b, riskTolerance);\n            \n            return riskScoreB - riskScoreA; // Higher risk first\n        });\n    }\n    \n    static optimizeForTime(scenarios: TestScenario[], maxTime: number): TestScenario[] {\n        // Greedy algorithm to maximize value within time constraint\n        const sortedByValue = scenarios.sort((a, b) => {\n            const valueA = this.calculateTestValue(a) / a.estimatedDuration;\n            const valueB = this.calculateTestValue(b) / b.estimatedDuration;\n            return valueB - valueA;\n        });\n        \n        const selected: TestScenario[] = [];\n        let totalTime = 0;\n        \n        for (const scenario of sortedByValue) {\n            if (totalTime + scenario.estimatedDuration <= maxTime) {\n                selected.push(scenario);\n                totalTime += scenario.estimatedDuration;\n            }\n        }\n        \n        return selected;\n    }\n    \n    static calculateCoverage(selectedScenarios: TestScenario[], allScenarios: TestScenario[]): {\n        codeAreasCovered: string[];\n        businessFunctionsCovered: string[];\n        coveragePercentage: number;\n    } {\n        const allCodeAreas = new Set(allScenarios.flatMap(s => s.coverage.codeAreas));\n        const allBusinessFunctions = new Set(allScenarios.flatMap(s => s.coverage.businessFunctions));\n        \n        const coveredCodeAreas = new Set(selectedScenarios.flatMap(s => s.coverage.codeAreas));\n        const coveredBusinessFunctions = new Set(selectedScenarios.flatMap(s => s.coverage.businessFunctions));\n        \n        const totalCoverageItems = allCodeAreas.size + allBusinessFunctions.size;\n        const coveredItems = coveredCodeAreas.size + coveredBusinessFunctions.size;\n        \n        return {\n            codeAreasCovered: Array.from(coveredCodeAreas),\n            businessFunctionsCovered: Array.from(coveredBusinessFunctions),\n            coveragePercentage: totalCoverageItems > 0 ? (coveredItems / totalCoverageItems) * 100 : 0\n        };\n    }\n    \n    static predictFailures(scenarios: TestScenario[]): Array<{scenario: TestScenario, failureProbability: number}> {\n        return scenarios.map(scenario => {\n            const failureProbability = this.calculateFailureProbability(scenario);\n            return { scenario, failureProbability };\n        }).sort((a, b) => b.failureProbability - a.failureProbability);\n    }\n    \n    private static prioritizeByCodeChanges(scenarios: TestScenario[], codeChanges: {\n        modifiedFiles: string[];\n        affectedAreas: string[];\n    }): TestScenario[] {\n        return scenarios.sort((a, b) => {\n            const relevanceA = this.calculateCodeChangeRelevance(a, codeChanges);\n            const relevanceB = this.calculateCodeChangeRelevance(b, codeChanges);\n            \n            return relevanceB - relevanceA;\n        });\n    }\n    \n    private static calculateCodeChangeRelevance(scenario: TestScenario, codeChanges: {\n        modifiedFiles: string[];\n        affectedAreas: string[];\n    }): number {\n        let relevance = 0;\n        \n        // Check if scenario file path matches modified files\n        const scenarioDir = scenario.filePath.split('/').slice(0, -1).join('/');\n        for (const modifiedFile of codeChanges.modifiedFiles) {\n            if (modifiedFile.includes(scenarioDir) || scenarioDir.includes(modifiedFile)) {\n                relevance += 10;\n            }\n        }\n        \n        // Check if scenario covers affected areas\n        for (const affectedArea of codeChanges.affectedAreas) {\n            if (scenario.coverage.codeAreas.includes(affectedArea)) {\n                relevance += 5;\n            }\n        }\n        \n        return relevance;\n    }\n    \n    private static calculateRiskScore(scenario: TestScenario, riskTolerance: string): number {\n        let riskScore = 0;\n        \n        // Historical failure rate contributes to risk\n        riskScore += (1 - scenario.historicalData.successRate) * 10;\n        \n        // Flakiness contributes to risk\n        riskScore += scenario.historicalData.flakiness * 5;\n        \n        // Recent failures increase risk\n        if (scenario.historicalData.lastFailure) {\n            const daysSinceFailure = (Date.now() - scenario.historicalData.lastFailure.getTime()) / (1000 * 60 * 60 * 24);\n            if (daysSinceFailure < 7) {\n                riskScore += (7 - daysSinceFailure) * 2;\n            }\n        }\n        \n        // Critical tags increase risk priority\n        if (scenario.tags.includes('@critical')) {\n            riskScore += 15;\n        }\n        if (scenario.tags.includes('@high')) {\n            riskScore += 10;\n        }\n        \n        // Adjust for risk tolerance\n        const toleranceMultiplier = {\n            'low': 0.5,\n            'medium': 1.0,\n            'high': 2.0\n        }[riskTolerance] || 1.0;\n        \n        return riskScore * toleranceMultiplier;\n    }\n    \n    private static calculateTestValue(scenario: TestScenario): number {\n        let value = 0;\n        \n        // Coverage value\n        value += scenario.coverage.codeAreas.length * 2;\n        value += scenario.coverage.businessFunctions.length * 3;\n        \n        // Priority tags add value\n        if (scenario.tags.includes('@critical')) value += 20;\n        if (scenario.tags.includes('@high')) value += 15;\n        if (scenario.tags.includes('@smoke')) value += 10;\n        \n        // Success rate adds value (reliable tests are more valuable)\n        value += scenario.historicalData.successRate * 10;\n        \n        // Reduce value for flaky tests\n        value -= scenario.historicalData.flakiness * 5;\n        \n        return Math.max(value, 1); // Ensure positive value\n    }\n    \n    private static optimizeForCoverage(scenarios: TestScenario[], minCoverage: number): TestScenario[] {\n        const selected: TestScenario[] = [];\n        const remainingScenarios = [...scenarios];\n        \n        while (remainingScenarios.length > 0) {\n            const currentCoverage = this.calculateCoverage(selected, scenarios);\n            \n            if (currentCoverage.coveragePercentage >= minCoverage) {\n                break;\n            }\n            \n            // Find scenario that adds the most coverage\n            let bestScenario: TestScenario | null = null;\n            let bestCoverageGain = 0;\n            \n            for (const scenario of remainingScenarios) {\n                const testCoverage = this.calculateCoverage([...selected, scenario], scenarios);\n                const coverageGain = testCoverage.coveragePercentage - currentCoverage.coveragePercentage;\n                \n                if (coverageGain > bestCoverageGain) {\n                    bestCoverageGain = coverageGain;\n                    bestScenario = scenario;\n                }\n            }\n            \n            if (bestScenario) {\n                selected.push(bestScenario);\n                const index = remainingScenarios.indexOf(bestScenario);\n                remainingScenarios.splice(index, 1);\n            } else {\n                break; // No more coverage gains possible\n            }\n        }\n        \n        return selected;\n    }\n    \n    private static assessRisk(scenarios: TestScenario[]): {\n        highRiskScenarios: number;\n        expectedFailures: number;\n        confidenceLevel: number;\n    } {\n        const highRiskScenarios = scenarios.filter(s => \n            s.historicalData.successRate < 0.8 || s.historicalData.flakiness > 0.3\n        ).length;\n        \n        const expectedFailures = scenarios.reduce((sum, s) => \n            sum + (1 - s.historicalData.successRate), 0\n        );\n        \n        const avgSuccessRate = scenarios.reduce((sum, s) => \n            sum + s.historicalData.successRate, 0\n        ) / scenarios.length;\n        \n        const confidenceLevel = avgSuccessRate * 100;\n        \n        return {\n            highRiskScenarios,\n            expectedFailures: Math.round(expectedFailures),\n            confidenceLevel: Math.round(confidenceLevel)\n        };\n    }\n    \n    private static calculateFailureProbability(scenario: TestScenario): number {\n        const baseFailureRate = 1 - scenario.historicalData.successRate;\n        const flakinessBonus = scenario.historicalData.flakiness * 0.3;\n        \n        // Recent failure increases probability\n        let recentFailureBonus = 0;\n        if (scenario.historicalData.lastFailure) {\n            const daysSinceFailure = (Date.now() - scenario.historicalData.lastFailure.getTime()) / (1000 * 60 * 60 * 24);\n            if (daysSinceFailure < 3) {\n                recentFailureBonus = 0.2;\n            } else if (daysSinceFailure < 7) {\n                recentFailureBonus = 0.1;\n            }\n        }\n        \n        return Math.min(baseFailureRate + flakinessBonus + recentFailureBonus, 1.0);\n    }\n}\n```\n\n### **Task 3: Build CI/CD Integration Framework (10 minutes)**\n\nCreate comprehensive CI/CD integration with intelligent execution strategies.\n\n**File**: `scripts/ci-integration.ts`\n\n```typescript\n// scripts/ci-integration.ts\n/**\n * TODO: Build CI/CD integration framework\n * Requirements:\n * 1. Detect CI environment and adapt execution strategy\n * 2. Implement parallel execution with resource management\n * 3. Create failure handling and retry mechanisms\n * 4. Generate comprehensive reports for different stakeholders\n * 5. Integrate with external tools (Slack, JIRA, etc.)\n */\n\nexport interface CIEnvironment {\n    platform: 'github' | 'gitlab' | 'jenkins' | 'azure' | 'local';\n    trigger: 'push' | 'pr' | 'schedule' | 'manual';\n    branch: string;\n    commit: string;\n    pullRequest?: {\n        number: number;\n        target: string;\n        author: string;\n    };\n    resources: {\n        workers: number;\n        memory: string;\n        timeout: number;\n    };\n}\n\nexport interface ExecutionPlan {\n    strategy: string;\n    parallelGroups: ParallelGroup[];\n    retryPolicy: RetryPolicy;\n    reportingConfig: ReportingConfig;\n    notificationConfig: NotificationConfig;\n}\n\nexport interface ParallelGroup {\n    id: string;\n    name: string;\n    tagExpression: string;\n    estimatedDuration: number;\n    resourceRequirements: ResourceRequirements;\n}\n\nexport interface RetryPolicy {\n    maxRetries: number;\n    retryConditions: string[];\n    backoffStrategy: 'linear' | 'exponential' | 'fixed';\n    retryDelay: number;\n}\n\n// TODO: Implement CIIntegrationManager class with:\n// - detectEnvironment(): CIEnvironment\n// - createExecutionPlan(environment: CIEnvironment): ExecutionPlan\n// - executeParallelGroups(plan: ExecutionPlan): ExecutionResult[]\n// - handleFailures(results: ExecutionResult[], retryPolicy: RetryPolicy): void\n// - generateReports(results: ExecutionResult[], config: ReportingConfig): void\n// - sendNotifications(results: ExecutionResult[], config: NotificationConfig): void\n```\n\n**Expected Implementation:**\n```typescript\n// scripts/ci-integration.ts - Solution\nimport { spawn } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport interface CIEnvironment {\n    platform: 'github' | 'gitlab' | 'jenkins' | 'azure' | 'local';\n    trigger: 'push' | 'pr' | 'schedule' | 'manual';\n    branch: string;\n    commit: string;\n    pullRequest?: {\n        number: number;\n        target: string;\n        author: string;\n    };\n    resources: {\n        workers: number;\n        memory: string;\n        timeout: number;\n    };\n}\n\nexport interface ExecutionPlan {\n    strategy: string;\n    parallelGroups: ParallelGroup[];\n    retryPolicy: RetryPolicy;\n    reportingConfig: ReportingConfig;\n    notificationConfig: NotificationConfig;\n}\n\nexport interface ParallelGroup {\n    id: string;\n    name: string;\n    tagExpression: string;\n    estimatedDuration: number;\n    resourceRequirements: ResourceRequirements;\n}\n\nexport interface RetryPolicy {\n    maxRetries: number;\n    retryConditions: string[];\n    backoffStrategy: 'linear' | 'exponential' | 'fixed';\n    retryDelay: number;\n}\n\nexport interface ResourceRequirements {\n    cpu: string;\n    memory: string;\n    browsers: string[];\n}\n\nexport interface ReportingConfig {\n    formats: ('json' | 'html' | 'junit' | 'slack')[];\n    outputDir: string;\n    includeScreenshots: boolean;\n    includeLogs: boolean;\n}\n\nexport interface NotificationConfig {\n    channels: Array<{\n        type: 'slack' | 'email' | 'teams';\n        webhook?: string;\n        recipients?: string[];\n        conditions: string[];\n    }>;\n}\n\nexport interface ExecutionResult {\n    groupId: string;\n    success: boolean;\n    duration: number;\n    scenariosRun: number;\n    scenariosPassed: number;\n    scenariosFailed: number;\n    errors: string[];\n    reportPath?: string;\n}\n\nexport class CIIntegrationManager {\n    static detectEnvironment(): CIEnvironment {\n        const env = process.env;\n        \n        // GitHub Actions\n        if (env.GITHUB_ACTIONS) {\n            return {\n                platform: 'github',\n                trigger: env.GITHUB_EVENT_NAME === 'pull_request' ? 'pr' : 'push',\n                branch: env.GITHUB_REF?.replace('refs/heads/', '') || 'unknown',\n                commit: env.GITHUB_SHA || 'unknown',\n                pullRequest: env.GITHUB_EVENT_NAME === 'pull_request' ? {\n                    number: parseInt(env.GITHUB_PR_NUMBER || '0'),\n                    target: env.GITHUB_BASE_REF || 'main',\n                    author: env.GITHUB_ACTOR || 'unknown'\n                } : undefined,\n                resources: {\n                    workers: parseInt(env.PARALLEL_WORKERS || '2'),\n                    memory: env.RUNNER_MEMORY || '7GB',\n                    timeout: parseInt(env.TIMEOUT_MINUTES || '30') * 60000\n                }\n            };\n        }\n        \n        // GitLab CI\n        if (env.GITLAB_CI) {\n            return {\n                platform: 'gitlab',\n                trigger: env.CI_PIPELINE_SOURCE === 'merge_request_event' ? 'pr' : 'push',\n                branch: env.CI_COMMIT_REF_NAME || 'unknown',\n                commit: env.CI_COMMIT_SHA || 'unknown',\n                pullRequest: env.CI_MERGE_REQUEST_IID ? {\n                    number: parseInt(env.CI_MERGE_REQUEST_IID),\n                    target: env.CI_MERGE_REQUEST_TARGET_BRANCH_NAME || 'main',\n                    author: env.GITLAB_USER_NAME || 'unknown'\n                } : undefined,\n                resources: {\n                    workers: parseInt(env.PARALLEL_WORKERS || '2'),\n                    memory: '4GB',\n                    timeout: 30 * 60000\n                }\n            };\n        }\n        \n        // Jenkins\n        if (env.JENKINS_URL) {\n            return {\n                platform: 'jenkins',\n                trigger: env.BUILD_CAUSE?.includes('SCMTrigger') ? 'push' : 'manual',\n                branch: env.GIT_BRANCH?.replace('origin/', '') || 'unknown',\n                commit: env.GIT_COMMIT || 'unknown',\n                resources: {\n                    workers: parseInt(env.PARALLEL_WORKERS || '1'),\n                    memory: '2GB',\n                    timeout: 45 * 60000\n                }\n            };\n        }\n        \n        // Local development\n        return {\n            platform: 'local',\n            trigger: 'manual',\n            branch: 'local',\n            commit: 'local',\n            resources: {\n                workers: parseInt(env.PARALLEL_WORKERS || '1'),\n                memory: '4GB',\n                timeout: 60 * 60000\n            }\n        };\n    }\n    \n    static createExecutionPlan(environment: CIEnvironment): ExecutionPlan {\n        let strategy: string;\n        let parallelGroups: ParallelGroup[];\n        \n        // Select strategy based on environment\n        switch (environment.trigger) {\n            case 'pr':\n                strategy = environment.platform === 'github' ? 'github-pr' : 'pr-validation';\n                parallelGroups = this.createPRValidationGroups(environment);\n                break;\n                \n            case 'push':\n                strategy = environment.branch === 'main' ? 'main-branch' : 'feature-branch';\n                parallelGroups = this.createPushValidationGroups(environment);\n                break;\n                \n            case 'schedule':\n                strategy = 'nightly-comprehensive';\n                parallelGroups = this.createNightlyGroups(environment);\n                break;\n                \n            case 'manual':\n            default:\n                strategy = 'manual-execution';\n                parallelGroups = this.createManualGroups(environment);\n                break;\n        }\n        \n        return {\n            strategy,\n            parallelGroups,\n            retryPolicy: this.createRetryPolicy(environment),\n            reportingConfig: this.createReportingConfig(environment),\n            notificationConfig: this.createNotificationConfig(environment)\n        };\n    }\n    \n    static async executeParallelGroups(plan: ExecutionPlan): Promise<ExecutionResult[]> {\n        const results: ExecutionResult[] = [];\n        \n        console.log(`üöÄ Executing ${plan.parallelGroups.length} parallel groups for strategy: ${plan.strategy}`);\n        \n        const promises = plan.parallelGroups.map(async (group) => {\n            console.log(`üìã Starting group: ${group.name}`);\n            const startTime = Date.now();\n            \n            try {\n                const result = await this.executeGroup(group);\n                const duration = Date.now() - startTime;\n                \n                const executionResult: ExecutionResult = {\n                    groupId: group.id,\n                    success: result.success,\n                    duration,\n                    scenariosRun: result.scenariosRun,\n                    scenariosPassed: result.scenariosPassed,\n                    scenariosFailed: result.scenariosFailed,\n                    errors: result.errors,\n                    reportPath: result.reportPath\n                };\n                \n                console.log(`‚úÖ Group ${group.name} completed: ${executionResult.scenariosPassed}/${executionResult.scenariosRun} passed`);\n                return executionResult;\n                \n            } catch (error) {\n                const duration = Date.now() - startTime;\n                const executionResult: ExecutionResult = {\n                    groupId: group.id,\n                    success: false,\n                    duration,\n                    scenariosRun: 0,\n                    scenariosPassed: 0,\n                    scenariosFailed: 0,\n                    errors: [error.message],\n                };\n                \n                console.error(`‚ùå Group ${group.name} failed: ${error.message}`);\n                return executionResult;\n            }\n        });\n        \n        const groupResults = await Promise.all(promises);\n        results.push(...groupResults);\n        \n        return results;\n    }\n    \n    static async handleFailures(results: ExecutionResult[], retryPolicy: RetryPolicy): Promise<ExecutionResult[]> {\n        const failedGroups = results.filter(r => !r.success);\n        \n        if (failedGroups.length === 0) {\n            return results;\n        }\n        \n        console.log(`üîÑ Retrying ${failedGroups.length} failed groups`);\n        \n        const retryResults: ExecutionResult[] = [];\n        \n        for (const failedResult of failedGroups) {\n            let retryCount = 0;\n            let success = false;\n            \n            while (retryCount < retryPolicy.maxRetries && !success) {\n                retryCount++;\n                \n                // Calculate delay\n                let delay = retryPolicy.retryDelay;\n                if (retryPolicy.backoffStrategy === 'exponential') {\n                    delay = retryPolicy.retryDelay * Math.pow(2, retryCount - 1);\n                } else if (retryPolicy.backoffStrategy === 'linear') {\n                    delay = retryPolicy.retryDelay * retryCount;\n                }\n                \n                console.log(`‚è≥ Waiting ${delay}ms before retry ${retryCount}/${retryPolicy.maxRetries}`);\n                await new Promise(resolve => setTimeout(resolve, delay));\n                \n                // Retry logic would go here\n                console.log(`üîÑ Retry attempt ${retryCount} for group ${failedResult.groupId}`);\n                // For now, simulate random success\n                success = Math.random() > 0.3;\n            }\n            \n            retryResults.push({\n                ...failedResult,\n                success,\n                errors: success ? [] : [...failedResult.errors, `Failed after ${retryCount} retries`]\n            });\n        }\n        \n        // Replace failed results with retry results\n        const updatedResults = results.map(r => \n            retryResults.find(retry => retry.groupId === r.groupId) || r\n        );\n        \n        return updatedResults;\n    }\n    \n    private static createPRValidationGroups(environment: CIEnvironment): ParallelGroup[] {\n        return [\n            {\n                id: 'pr-smoke',\n                name: 'PR Smoke Tests',\n                tagExpression: '@smoke and @fast and not @flaky',\n                estimatedDuration: 300000, // 5 minutes\n                resourceRequirements: {\n                    cpu: '2 cores',\n                    memory: '4GB',\n                    browsers: ['chromium']\n                }\n            },\n            {\n                id: 'pr-affected',\n                name: 'PR Affected Areas',\n                tagExpression: '@affected-by-pr and not @slow',\n                estimatedDuration: 600000, // 10 minutes\n                resourceRequirements: {\n                    cpu: '2 cores',\n                    memory: '4GB',\n                    browsers: ['chromium', 'firefox']\n                }\n            }\n        ];\n    }\n    \n    private static createPushValidationGroups(environment: CIEnvironment): ParallelGroup[] {\n        if (environment.branch === 'main') {\n            return [\n                {\n                    id: 'main-regression',\n                    name: 'Main Branch Regression',\n                    tagExpression: '@regression and not @flaky',\n                    estimatedDuration: 1800000, // 30 minutes\n                    resourceRequirements: {\n                        cpu: '4 cores',\n                        memory: '8GB',\n                        browsers: ['chromium', 'firefox']\n                    }\n                }\n            ];\n        } else {\n            return [\n                {\n                    id: 'feature-validation',\n                    name: 'Feature Branch Validation',\n                    tagExpression: '@smoke and @integration',\n                    estimatedDuration: 900000, // 15 minutes\n                    resourceRequirements: {\n                        cpu: '2 cores',\n                        memory: '4GB',\n                        browsers: ['chromium']\n                    }\n                }\n            ];\n        }\n    }\n    \n    private static createNightlyGroups(environment: CIEnvironment): ParallelGroup[] {\n        return [\n            {\n                id: 'nightly-comprehensive',\n                name: 'Comprehensive Test Suite',\n                tagExpression: '@comprehensive or @e2e',\n                estimatedDuration: 7200000, // 2 hours\n                resourceRequirements: {\n                    cpu: '8 cores',\n                    memory: '16GB',\n                    browsers: ['chromium', 'firefox', 'webkit']\n                }\n            },\n            {\n                id: 'nightly-performance',\n                name: 'Performance Tests',\n                tagExpression: '@performance',\n                estimatedDuration: 2700000, // 45 minutes\n                resourceRequirements: {\n                    cpu: '8 cores',\n                    memory: '32GB',\n                    browsers: ['chromium']\n                }\n            }\n        ];\n    }\n    \n    private static createManualGroups(environment: CIEnvironment): ParallelGroup[] {\n        return [\n            {\n                id: 'manual-selected',\n                name: 'Manually Selected Tests',\n                tagExpression: process.env.TAG_EXPRESSION || '@smoke',\n                estimatedDuration: 1200000, // 20 minutes\n                resourceRequirements: {\n                    cpu: '4 cores',\n                    memory: '8GB',\n                    browsers: ['chromium', 'firefox']\n                }\n            }\n        ];\n    }\n    \n    private static createRetryPolicy(environment: CIEnvironment): RetryPolicy {\n        return {\n            maxRetries: environment.platform === 'local' ? 1 : 2,\n            retryConditions: ['FAILED', 'TIMEOUT', 'INFRASTRUCTURE_ERROR'],\n            backoffStrategy: 'exponential',\n            retryDelay: 5000\n        };\n    }\n    \n    private static createReportingConfig(environment: CIEnvironment): ReportingConfig {\n        return {\n            formats: ['json', 'html', 'junit'],\n            outputDir: './reports',\n            includeScreenshots: true,\n            includeLogs: environment.platform !== 'local'\n        };\n    }\n    \n    private static createNotificationConfig(environment: CIEnvironment): NotificationConfig {\n        const channels = [];\n        \n        if (process.env.SLACK_WEBHOOK_URL) {\n            channels.push({\n                type: 'slack' as const,\n                webhook: process.env.SLACK_WEBHOOK_URL,\n                conditions: ['FAILURE', 'SUCCESS_AFTER_RETRY']\n            });\n        }\n        \n        return { channels };\n    }\n    \n    private static async executeGroup(group: ParallelGroup): Promise<{\n        success: boolean;\n        scenariosRun: number;\n        scenariosPassed: number;\n        scenariosFailed: number;\n        errors: string[];\n        reportPath?: string;\n    }> {\n        // This would execute the actual Cucumber command\n        // For demo purposes, we'll simulate execution\n        \n        const reportPath = `./reports/${group.id}-report.json`;\n        \n        return new Promise((resolve) => {\n            // Simulate test execution\n            setTimeout(() => {\n                const scenariosRun = Math.floor(Math.random() * 20) + 5;\n                const failureRate = Math.random() * 0.1; // 0-10% failure rate\n                const scenariosFailed = Math.floor(scenariosRun * failureRate);\n                const scenariosPassed = scenariosRun - scenariosFailed;\n                \n                resolve({\n                    success: scenariosFailed === 0,\n                    scenariosRun,\n                    scenariosPassed,\n                    scenariosFailed,\n                    errors: scenariosFailed > 0 ? [`${scenariosFailed} scenarios failed`] : [],\n                    reportPath\n                });\n            }, 1000); // Simulate 1 second execution\n        });\n    }\n}\n```\n\n### **Task 4: Create Performance Monitoring (5 minutes)**\n\nImplement performance monitoring and optimization for test execution.\n\n**File**: `config/performance-monitor.ts`\n\n```typescript\n// config/performance-monitor.ts\n/**\n * TODO: Build performance monitoring system\n * Requirements:\n * 1. Monitor test execution performance in real-time\n * 2. Identify performance bottlenecks and slow tests\n * 3. Provide optimization recommendations\n * 4. Track resource utilization during execution\n * 5. Generate performance reports and trends\n */\n\nexport interface PerformanceMetrics {\n    executionTime: number;\n    memoryUsage: {\n        peak: number;\n        average: number;\n        current: number;\n    };\n    cpuUsage: {\n        peak: number;\n        average: number;\n        current: number;\n    };\n    scenarioMetrics: ScenarioPerformanceMetric[];\n}\n\nexport interface ScenarioPerformanceMetric {\n    name: string;\n    duration: number;\n    memoryDelta: number;\n    stepTimings: number[];\n    bottlenecks: string[];\n}\n\n// TODO: Implement PerformanceMonitor class with:\n// - startMonitoring(): void\n// - recordScenarioMetrics(scenario: string, metrics: ScenarioPerformanceMetric): void\n// - analyzeBottlenecks(): BottleneckAnalysis\n// - generateOptimizationRecommendations(): OptimizationRecommendation[]\n// - exportPerformanceReport(): PerformanceReport\n```\n\n## üß™ Integration Testing\n\nCreate comprehensive test scenarios to validate your advanced execution control system:\n\n**File**: `features/advanced-execution-control.feature`\n\n```gherkin\nFeature: Advanced Execution Control\n  As a DevOps engineer\n  I want to have sophisticated test execution control\n  So that I can optimize CI/CD pipeline efficiency and reliability\n\n  @smoke @fast @execution-control\n  Scenario: Intelligent test selection based on code changes\n    Given I have a repository with recent code changes\n    And I have historical test data available\n    When I run intelligent test selection\n    Then tests related to changed code should be prioritized\n    And the total execution time should be optimized\n    And coverage requirements should be met\n\n  @integration @ci-pipeline @execution-control\n  Scenario: CI environment detection and strategy adaptation\n    Given I am running in a CI environment\n    When the execution control system detects the environment\n    Then the appropriate execution strategy should be selected\n    And parallel execution should be optimized for available resources\n    And retry policies should be configured correctly\n\n  @performance @monitoring @execution-control\n  Scenario: Performance monitoring and bottleneck detection\n    Given I am running a comprehensive test suite\n    When performance monitoring is enabled\n    Then execution metrics should be collected in real-time\n    And performance bottlenecks should be identified\n    And optimization recommendations should be generated\n\n  @advanced @tag-expressions @execution-control\n  Scenario: Complex tag expression evaluation\n    Given I have complex tag expressions with nested conditions\n    When I evaluate the expressions against scenario tags\n    Then the boolean logic should be correctly applied\n    And runtime conditions should be properly evaluated\n    And performance should be optimized for large test suites\n```\n\n## ‚úÖ Validation Checklist\n\n### **Tag Expression Engine (25%)**\n- ‚úÖ Complex boolean expression parsing\n- ‚úÖ Runtime variable substitution\n- ‚úÖ Performance-optimized evaluation\n- ‚úÖ Conditional logic based on environment\n\n### **Intelligent Test Selection (25%)**\n- ‚úÖ Code change analysis and test prioritization\n- ‚úÖ Historical data integration\n- ‚úÖ Risk-based selection algorithms\n- ‚úÖ Coverage optimization\n\n### **CI/CD Integration (25%)**\n- ‚úÖ Environment detection and adaptation\n- ‚úÖ Parallel execution management\n- ‚úÖ Failure handling and retry mechanisms\n- ‚úÖ Report generation and notifications\n\n### **Performance Monitoring (25%)**\n- ‚úÖ Real-time metrics collection\n- ‚úÖ Bottleneck identification\n- ‚úÖ Resource utilization tracking\n- ‚úÖ Optimization recommendations\n\n## üéØ Success Criteria\n\n**Minimum Requirements:**\n- Tag expression engine handles complex boolean logic\n- Intelligent selection considers multiple factors\n- CI/CD integration works for at least 2 platforms\n- Basic performance monitoring is implemented\n\n**Excellence Indicators:**\n- Sophisticated runtime condition evaluation\n- Machine learning-inspired test prioritization\n- Comprehensive CI/CD platform support\n- Advanced performance optimization recommendations\n\n## üîó Next Steps\n\nAfter completing this exercise:\n1. Deploy your system in a real CI/CD environment\n2. Collect performance data and refine algorithms\n3. Integrate with additional tools and platforms\n4. Move on to [Exercise 04: Production Integration Challenge](./04-production-integration-challenge.md)\n\n---\n\n**Estimated Completion Time**: 45 minutes  \n**Difficulty Level**: Advanced  \n**Skills Developed**: Complex tag expressions, intelligent test selection, CI/CD integration, performance optimization\n